# Phase 4: Build MCP Shim - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a thin MCP server that extracts git author/repo info locally and forwards requests to the central API.

**Architecture:** MCP server (stdio) that proxies to HTTP API. Extracts git config at startup, attaches to all requests via headers.

**Tech Stack:** Go 1.23, MCP SDK, standard http client

**Prerequisites:** Phase 3 complete (API server exists)

---

## Task 1: Create Git Info Extraction

**Files:**
- Create: `internal/gitinfo/gitinfo.go`
- Create: `internal/gitinfo/gitinfo_test.go`

**Step 1: Write failing test**

```go
// internal/gitinfo/gitinfo_test.go
package gitinfo_test

import (
	"testing"

	"github.com/MereWhiplash/engram-cogitator/internal/gitinfo"
)

func TestNormalizeRemoteURL(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"git@github.com:myorg/myrepo.git", "myorg/myrepo"},
		{"https://github.com/myorg/myrepo.git", "myorg/myrepo"},
		{"https://github.com/myorg/myrepo", "myorg/myrepo"},
		{"git@gitlab.com:team/project.git", "team/project"},
		{"ssh://git@github.com/myorg/myrepo.git", "myorg/myrepo"},
		{"https://user:pass@github.com/myorg/myrepo.git", "myorg/myrepo"},
	}

	for _, tc := range tests {
		t.Run(tc.input, func(t *testing.T) {
			result := gitinfo.NormalizeRemoteURL(tc.input)
			if result != tc.expected {
				t.Errorf("NormalizeRemoteURL(%q) = %q, want %q", tc.input, result, tc.expected)
			}
		})
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/gitinfo/... -v`
Expected: FAIL with "undefined: gitinfo.NormalizeRemoteURL"

**Step 3: Write implementation**

```go
// internal/gitinfo/gitinfo.go
package gitinfo

import (
	"os/exec"
	"regexp"
	"strings"
)

// Info holds git configuration info
type Info struct {
	AuthorName  string
	AuthorEmail string
	Repo        string
}

// Get extracts git info from the current directory
func Get() (*Info, error) {
	info := &Info{}

	// Get author name
	if out, err := exec.Command("git", "config", "user.name").Output(); err == nil {
		info.AuthorName = strings.TrimSpace(string(out))
	}

	// Get author email
	if out, err := exec.Command("git", "config", "user.email").Output(); err == nil {
		info.AuthorEmail = strings.TrimSpace(string(out))
	}

	// Get remote URL
	if out, err := exec.Command("git", "config", "--get", "remote.origin.url").Output(); err == nil {
		info.Repo = NormalizeRemoteURL(strings.TrimSpace(string(out)))
	}

	return info, nil
}

// NormalizeRemoteURL converts various git remote URL formats to "org/repo"
func NormalizeRemoteURL(url string) string {
	url = strings.TrimSpace(url)

	// Remove .git suffix
	url = strings.TrimSuffix(url, ".git")

	// Handle SSH format: git@github.com:org/repo
	if strings.HasPrefix(url, "git@") {
		// git@github.com:org/repo -> org/repo
		re := regexp.MustCompile(`git@[^:]+:(.+)`)
		if matches := re.FindStringSubmatch(url); len(matches) > 1 {
			return matches[1]
		}
	}

	// Handle ssh:// format: ssh://git@github.com/org/repo
	if strings.HasPrefix(url, "ssh://") {
		url = strings.TrimPrefix(url, "ssh://")
		// Remove user@host part
		if idx := strings.Index(url, "/"); idx != -1 {
			url = url[idx+1:]
		}
		return url
	}

	// Handle HTTPS format: https://github.com/org/repo
	// Also handles https://user:pass@github.com/org/repo
	if strings.HasPrefix(url, "https://") || strings.HasPrefix(url, "http://") {
		// Remove protocol
		url = strings.TrimPrefix(url, "https://")
		url = strings.TrimPrefix(url, "http://")

		// Remove user:pass@ if present
		if idx := strings.Index(url, "@"); idx != -1 {
			url = url[idx+1:]
		}

		// Remove host
		if idx := strings.Index(url, "/"); idx != -1 {
			url = url[idx+1:]
		}
		return url
	}

	return url
}
```

**Step 4: Run tests**

Run: `go test ./internal/gitinfo/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/gitinfo/
git commit -m "feat(gitinfo): add git info extraction and URL normalization"
```

---

## Task 2: Create API Client

**Files:**
- Create: `internal/client/client.go`
- Create: `internal/client/client_test.go`

**Step 1: Write client**

```go
// internal/client/client.go
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/MereWhiplash/engram-cogitator/internal/api"
	"github.com/MereWhiplash/engram-cogitator/internal/gitinfo"
	"github.com/MereWhiplash/engram-cogitator/internal/storage"
)

// Client is an HTTP client for the central API
type Client struct {
	baseURL string
	gitInfo *gitinfo.Info
	http    *http.Client
}

// New creates a new API client
func New(baseURL string, gitInfo *gitinfo.Info) *Client {
	return &Client{
		baseURL: baseURL,
		gitInfo: gitInfo,
		http: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func (c *Client) doRequest(ctx context.Context, method, path string, body interface{}) (*http.Response, error) {
	var reqBody io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request: %w", err)
		}
		reqBody = bytes.NewReader(jsonBody)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, reqBody)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")

	// Add git context headers
	if c.gitInfo != nil {
		if c.gitInfo.AuthorName != "" {
			req.Header.Set("X-EC-Author-Name", c.gitInfo.AuthorName)
		}
		if c.gitInfo.AuthorEmail != "" {
			req.Header.Set("X-EC-Author-Email", c.gitInfo.AuthorEmail)
		}
		if c.gitInfo.Repo != "" {
			req.Header.Set("X-EC-Repo", c.gitInfo.Repo)
		}
	}

	return c.http.Do(req)
}

// Add creates a new memory
func (c *Client) Add(ctx context.Context, memType, area, content, rationale string) (*storage.Memory, error) {
	req := api.AddRequest{
		Type:      memType,
		Area:      area,
		Content:   content,
		Rationale: rationale,
	}

	resp, err := c.doRequest(ctx, "POST", "/v1/memories", req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		var errResp api.ErrorResponse
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("API error: %s", errResp.Error)
	}

	var result api.AddResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Memory, nil
}

// Search finds memories by query
func (c *Client) Search(ctx context.Context, query string, limit int, memType, area string) ([]storage.Memory, error) {
	req := api.SearchRequest{
		Query: query,
		Limit: limit,
		Type:  memType,
		Area:  area,
	}

	resp, err := c.doRequest(ctx, "POST", "/v1/memories/search", req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp api.ErrorResponse
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("API error: %s", errResp.Error)
	}

	var result api.SearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Memories, nil
}

// List returns recent memories
func (c *Client) List(ctx context.Context, limit int, memType, area string, includeInvalid bool) ([]storage.Memory, error) {
	path := fmt.Sprintf("/v1/memories?limit=%d", limit)
	if memType != "" {
		path += "&type=" + memType
	}
	if area != "" {
		path += "&area=" + area
	}
	if includeInvalid {
		path += "&include_invalid=true"
	}

	resp, err := c.doRequest(ctx, "GET", path, nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp api.ErrorResponse
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("API error: %s", errResp.Error)
	}

	var result api.ListResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Memories, nil
}

// Invalidate marks a memory as invalid
func (c *Client) Invalidate(ctx context.Context, id int64, supersededBy *int64) error {
	req := api.InvalidateRequest{
		SupersededBy: supersededBy,
	}

	path := fmt.Sprintf("/v1/memories/%d/invalidate", id)
	resp, err := c.doRequest(ctx, "PUT", path, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp api.ErrorResponse
		json.NewDecoder(resp.Body).Decode(&errResp)
		return fmt.Errorf("API error: %s", errResp.Error)
	}

	return nil
}
```

**Step 2: Verify it compiles**

Run: `go build ./internal/client/...`
Expected: Success

**Step 3: Commit**

```bash
git add internal/client/
git commit -m "feat(client): add HTTP client for central API"
```

---

## Task 3: Create Shim MCP Handlers

**Files:**
- Create: `internal/shim/tools.go`
- Create: `internal/shim/tools_test.go`

**Step 1: Write shim tools**

```go
// internal/shim/tools.go
package shim

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/MereWhiplash/engram-cogitator/internal/client"
	"github.com/MereWhiplash/engram-cogitator/internal/storage"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// Handler holds shim dependencies
type Handler struct {
	client *client.Client
}

// NewHandler creates a new shim handler
func NewHandler(c *client.Client) *Handler {
	return &Handler{client: c}
}

// Input/Output types (same as tools package)
type AddInput struct {
	Type      string `json:"type" jsonschema:"required"`
	Area      string `json:"area" jsonschema:"required"`
	Content   string `json:"content" jsonschema:"required"`
	Rationale string `json:"rationale,omitempty"`
}

type AddOutput struct {
	Memory *storage.Memory `json:"memory"`
}

type SearchInput struct {
	Query string `json:"query" jsonschema:"required"`
	Limit int    `json:"limit,omitempty"`
	Type  string `json:"type,omitempty"`
	Area  string `json:"area,omitempty"`
}

type SearchOutput struct {
	Memories []storage.Memory `json:"memories"`
}

type InvalidateInput struct {
	ID           int64 `json:"id" jsonschema:"required"`
	SupersededBy int64 `json:"superseded_by,omitempty"`
}

type InvalidateOutput struct {
	Message string `json:"message"`
}

type ListInput struct {
	Limit          int    `json:"limit,omitempty"`
	Type           string `json:"type,omitempty"`
	Area           string `json:"area,omitempty"`
	IncludeInvalid bool   `json:"include_invalid,omitempty"`
}

type ListOutput struct {
	Memories []storage.Memory `json:"memories"`
}

func textResult(text string) *mcp.CallToolResult {
	return &mcp.CallToolResult{
		Content: []mcp.Content{&mcp.TextContent{Text: text}},
	}
}

func errorResult(msg string) *mcp.CallToolResult {
	return &mcp.CallToolResult{
		Content: []mcp.Content{&mcp.TextContent{Text: msg}},
		IsError: true,
	}
}

// Register adds all EC tools to the MCP server
func Register(server *mcp.Server, h *Handler) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "ec_add",
		Description: "Add a new memory entry (decision, learning, or pattern)",
	}, h.Add)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ec_search",
		Description: "Search memories by semantic similarity",
	}, h.Search)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ec_invalidate",
		Description: "Invalidate a memory entry (soft delete)",
	}, h.Invalidate)

	mcp.AddTool(server, &mcp.Tool{
		Name:        "ec_list",
		Description: "List recent memory entries",
	}, h.List)
}

func (h *Handler) Add(ctx context.Context, req *mcp.CallToolRequest, input AddInput) (*mcp.CallToolResult, AddOutput, error) {
	if input.Type == "" || input.Area == "" || input.Content == "" {
		return errorResult("type, area, and content are required"), AddOutput{}, nil
	}

	memory, err := h.client.Add(ctx, input.Type, input.Area, input.Content, input.Rationale)
	if err != nil {
		return errorResult(fmt.Sprintf("failed to store memory: %v", err)), AddOutput{}, nil
	}

	result, _ := json.MarshalIndent(memory, "", "  ")
	return textResult(fmt.Sprintf("Memory added successfully:\n%s", string(result))), AddOutput{Memory: memory}, nil
}

func (h *Handler) Search(ctx context.Context, req *mcp.CallToolRequest, input SearchInput) (*mcp.CallToolResult, SearchOutput, error) {
	if input.Query == "" {
		return errorResult("query is required"), SearchOutput{}, nil
	}

	limit := input.Limit
	if limit <= 0 {
		limit = 5
	}

	memories, err := h.client.Search(ctx, input.Query, limit, input.Type, input.Area)
	if err != nil {
		return errorResult(fmt.Sprintf("failed to search: %v", err)), SearchOutput{}, nil
	}

	if len(memories) == 0 {
		return textResult("No matching memories found."), SearchOutput{Memories: []storage.Memory{}}, nil
	}

	result, _ := json.MarshalIndent(memories, "", "  ")
	return textResult(string(result)), SearchOutput{Memories: memories}, nil
}

func (h *Handler) Invalidate(ctx context.Context, req *mcp.CallToolRequest, input InvalidateInput) (*mcp.CallToolResult, InvalidateOutput, error) {
	if input.ID == 0 {
		return errorResult("id is required"), InvalidateOutput{}, nil
	}

	var supersededBy *int64
	if input.SupersededBy > 0 {
		supersededBy = &input.SupersededBy
	}

	if err := h.client.Invalidate(ctx, input.ID, supersededBy); err != nil {
		return errorResult(fmt.Sprintf("failed to invalidate: %v", err)), InvalidateOutput{}, nil
	}

	msg := fmt.Sprintf("Memory %d has been invalidated.", input.ID)
	if supersededBy != nil {
		msg += fmt.Sprintf(" Superseded by memory %d.", *supersededBy)
	}

	return textResult(msg), InvalidateOutput{Message: msg}, nil
}

func (h *Handler) List(ctx context.Context, req *mcp.CallToolRequest, input ListInput) (*mcp.CallToolResult, ListOutput, error) {
	limit := input.Limit
	if limit <= 0 {
		limit = 10
	}

	memories, err := h.client.List(ctx, limit, input.Type, input.Area, input.IncludeInvalid)
	if err != nil {
		return errorResult(fmt.Sprintf("failed to list: %v", err)), ListOutput{}, nil
	}

	if len(memories) == 0 {
		return textResult("No memories found."), ListOutput{Memories: []storage.Memory{}}, nil
	}

	result, _ := json.MarshalIndent(memories, "", "  ")
	return textResult(string(result)), ListOutput{Memories: memories}, nil
}
```

**Step 2: Verify it compiles**

Run: `go build ./internal/shim/...`
Expected: Success

**Step 3: Commit**

```bash
git add internal/shim/
git commit -m "feat(shim): add MCP handlers that proxy to central API"
```

---

## Task 4: Create Shim Entry Point

**Files:**
- Create: `cmd/shim/main.go`

**Step 1: Write shim main**

```go
// cmd/shim/main.go
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/MereWhiplash/engram-cogitator/internal/client"
	"github.com/MereWhiplash/engram-cogitator/internal/gitinfo"
	"github.com/MereWhiplash/engram-cogitator/internal/shim"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

func main() {
	apiURL := flag.String("api-url", "", "Central API URL (required)")
	flag.Parse()

	// Check for env var if flag not set
	if *apiURL == "" {
		*apiURL = os.Getenv("EC_API_URL")
	}

	if *apiURL == "" {
		log.Fatal("API URL required: use --api-url or EC_API_URL environment variable")
	}

	// Extract git info
	gitInfo, err := gitinfo.Get()
	if err != nil {
		log.Printf("Warning: failed to get git info: %v", err)
		gitInfo = &gitinfo.Info{}
	}

	log.Printf("Git context: author=%s <%s>, repo=%s", gitInfo.AuthorName, gitInfo.AuthorEmail, gitInfo.Repo)

	// Create API client
	apiClient := client.New(*apiURL, gitInfo)

	// Create shim handler
	handler := shim.NewHandler(apiClient)

	// Create MCP server
	server := mcp.NewServer(&mcp.Implementation{
		Name:    "engram-cogitator",
		Version: "1.0.0",
	}, nil)

	// Register tools
	shim.Register(server, handler)

	// Handle graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-sigChan
		log.Println("Shutting down...")
		cancel()
	}()

	// Start server with stdio transport
	log.Println("Starting Engram Cogitator shim...")
	if err := server.Run(ctx, &mcp.StdioTransport{}); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
```

**Step 2: Verify build**

Run: `CGO_ENABLED=1 go build ./cmd/shim`
Expected: Success

**Step 3: Commit**

```bash
git add cmd/shim/main.go
git commit -m "feat(shim): add MCP shim entry point"
```

---

## Task 5: Create Shim Dockerfile

**Files:**
- Create: `Dockerfile.shim`

**Step 1: Write Dockerfile**

```dockerfile
# Dockerfile.shim
FROM golang:1.23-bookworm AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# Build shim (no CGO needed)
RUN CGO_ENABLED=0 GOOS=linux go build -o /ec-shim ./cmd/shim

# Runtime image
FROM gcr.io/distroless/static-debian12

COPY --from=builder /ec-shim /ec-shim

ENTRYPOINT ["/ec-shim"]
```

**Step 2: Verify build**

Run: `docker build -f Dockerfile.shim -t engram-shim:local .`
Expected: Success

**Step 3: Commit**

```bash
git add Dockerfile.shim
git commit -m "feat(shim): add Dockerfile for shim"
```

---

## Task 6: Update Install Script for Team Mode

**Files:**
- Modify: `install.sh` (add team mode section)

**Step 1: Add team mode installation option**

Append to install.sh:

```bash
# Team mode installation (add after existing solo mode setup)
install_team_mode() {
    echo "Installing team mode..."

    if [ -z "$EC_API_URL" ]; then
        echo "Error: EC_API_URL environment variable required for team mode"
        exit 1
    fi

    # Download shim binary
    SHIM_URL="https://github.com/MereWhiplash/engram-cogitator/releases/latest/download/ec-shim-$(uname -s | tr '[:upper:]' '[:lower:]')-$(uname -m)"
    curl -sSL "$SHIM_URL" -o /usr/local/bin/ec-shim
    chmod +x /usr/local/bin/ec-shim

    # Configure MCP
    claude mcp add engram-cogitator \
        --scope user \
        -- ec-shim --api-url "$EC_API_URL"

    echo "Team mode installed. Restart Claude Code to activate."
}

# Check for team mode flag
if [ "$1" = "--team" ]; then
    install_team_mode
    exit 0
fi
```

**Step 2: Commit**

```bash
git add install.sh
git commit -m "feat: add team mode installation option to install script"
```

---

## Summary

After Phase 4, you'll have:

```
cmd/
  server/main.go    # Solo mode MCP server
  api/main.go       # Team mode HTTP API server
  shim/main.go      # Team mode MCP shim

internal/
  gitinfo/          # Git info extraction
  client/           # HTTP client for API
  shim/             # MCP handlers for shim

Dockerfile.shim     # Container for shim (optional)
```

**Team mode usage:**
```bash
# Install shim
EC_API_URL=https://engram.internal.company.com ./install.sh --team

# Or manually
claude mcp add engram-cogitator -- ec-shim --api-url https://engram.internal.company.com
```

**Next phase:** Build Helm chart for K8s deployment.
